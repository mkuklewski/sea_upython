  --- This code is automatically generated by the addrgen_wb.py tool
  --- Please don't edit it manaully, unless you really have to do it.

  library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
  library general_cores;
  use general_cores.wishbone_pkg.all;
  library work;
  use work.agwb_DAC7311_wb_pkg.all;

  entity agwb_DAC7311_wb is
    port (
      slave_i : in t_wishbone_slave_in;
      slave_o : out t_wishbone_slave_out;

      Control_o : out  t_Control;
      Control_o_stb : out std_logic;
      Status_i : in  t_Status;
      Status_i_ack : out std_logic;

      rst_n_i : in std_logic;
      clk_sys_i : in std_logic
      );

  end agwb_DAC7311_wb;

  architecture gener of agwb_DAC7311_wb is
      signal int_Control_o : t_Control := stlv2t_Control(std_logic_vector(to_unsigned(163840,31))); -- Hex value: 0x28000
    signal int_Control_o_stb : std_logic;

    -- Internal WB declaration
    signal int_regs_wb_m_o : t_wishbone_master_out;
    signal int_regs_wb_m_i : t_wishbone_master_in;
    signal int_addr : std_logic_vector(2-1 downto 0);
    signal wb_up_o : t_wishbone_slave_out_array(0 to 0);
    signal wb_up_i : t_wishbone_slave_in_array(0 to 0);
    signal wb_m_o : t_wishbone_master_out_array(0 to 1-1);
    signal wb_m_i : t_wishbone_master_in_array(0 to 1-1);

    -- Constants
    constant c_address : t_wishbone_address_array(0 to 1-1) := (0=>"00000000000000000000000000000000");
    constant c_mask : t_wishbone_address_array(0 to 1-1) := (0=>"00000000000000000000000000000000");

  begin
    wb_up_i(0) <= slave_i;
    slave_o <= wb_up_o(0);
    int_addr <= int_regs_wb_m_o.adr(2-1 downto 0);

  -- Main crossbar
    xwb_crossbar_1: entity general_cores.xwb_crossbar
    generic map (
       g_num_masters => 1,
       g_num_slaves  => 1,
       g_registered  => false,
       g_address     => c_address,
       g_mask        => c_mask)
    port map (
       clk_sys_i => clk_sys_i,
       rst_n_i   => rst_n_i,
        slave_i   => wb_up_i,
        slave_o   => wb_up_o,
       master_i  => wb_m_i,
       master_o  => wb_m_o,
      sdb_sel_o => open);

  -- Process for register access
    process(clk_sys_i)
    begin
      if rising_edge(clk_sys_i) then
        if rst_n_i = '0' then
          -- Reset of the core
          int_regs_wb_m_i <= c_DUMMY_WB_MASTER_IN;
            int_Control_o <= stlv2t_Control(std_logic_vector(to_unsigned(163840,31))); -- Hex value: 0x28000

        else
          -- Normal operation
          int_regs_wb_m_i.rty <= '0';
          int_regs_wb_m_i.ack <= '0';
          int_regs_wb_m_i.err <= '0';
          int_Control_o_stb <= '0';
          Status_i_ack <= '0';

          if (int_regs_wb_m_o.cyc = '1') and (int_regs_wb_m_o.stb = '1') then
            int_regs_wb_m_i.err <= '1'; -- in case of missed address
            -- Access, now we handle consecutive registers
            case int_addr is
            when "10" => -- 0x2
               int_regs_wb_m_i.dat <= (others => '0');
               int_regs_wb_m_i.dat(30 downto 0) <= t_Control2stlv(int_Control_o);
               if int_regs_wb_m_o.we = '1' then
                 int_Control_o <= stlv2t_Control(int_regs_wb_m_o.dat(30 downto 0));
               if int_regs_wb_m_i.ack = '0' then
                  int_Control_o_stb <= '1';
               end if;
               end if;
               int_regs_wb_m_i.ack <= '1';
               int_regs_wb_m_i.err <= '0';
            when "11" => -- 0x3
               int_regs_wb_m_i.dat <= (others => '0');
               int_regs_wb_m_i.dat(0 downto 0) <= std_logic_vector(Status_i);
               if int_regs_wb_m_i.ack = '0' then
                  Status_i_ack <= '1';
               end if;
               int_regs_wb_m_i.ack <= '1';
               int_regs_wb_m_i.err <= '0';

            when "00" =>
               int_regs_wb_m_i.dat <= x"2a2de91d";
               int_regs_wb_m_i.ack <= '1';
               int_regs_wb_m_i.err <= '0';
            when "01" =>
               int_regs_wb_m_i.dat <= x"762a56fb";
               int_regs_wb_m_i.ack <= '1';
               int_regs_wb_m_i.err <= '0';
            when others =>
               int_regs_wb_m_i.dat <= x"A5A5A5A5";
               int_regs_wb_m_i.ack <= '1';
               int_regs_wb_m_i.err <= '0';
            end case;
          end if;
        end if;
      end if;
    end process;
    Control_o <= int_Control_o;
    Control_o_stb <= int_Control_o_stb;
    wb_m_i(0) <= int_regs_wb_m_i;
    int_regs_wb_m_o  <= wb_m_o(0);

  end architecture;
